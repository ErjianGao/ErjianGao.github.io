[{"title":"《月亮与六便士》- 毛姆","url":"/2021/10/08/《月亮与六便士》-毛姆/","content":"\n这是一部极具浪漫主义情怀的一部小说，毛姆对于人类心理的研究可以说是登峰造极了，读这本书的时候情绪简直就像坐过山车大起大落。当斯特里特兰德离开他的妻子时，我还能表示理解。或许这就是艺术家的理想主义，前40年我为了别人而活，40岁之后我为我的理想而活。但是这种理想主义在现实中又不具备可行性，人不能只为自己而活。一个人抛弃自己的妻儿只为了追寻心中的艺术理想，你可能觉得这就是个笑话，而且在绝大多数情况下真就是个令人发指的笑话，毕竟几千年才出这么一个高更。\n\n<img src=\"http://picbed.erjiangao.com/img/20211008235310.png\" alt=\"image-20211008235308523\" style=\"zoom:50%;\" />\n\n<!--more-->\n\n随着在巴黎与施特略夫夫妇的故事展开，作者就开始玩花活了。作者首先多次描写施特略夫夫妇的恩爱画面，随后又亲手将他构建起的温馨毁掉。当我看到斯特里特兰德将夫妇拆散时，我真是气得快要摔手机了。或许夫妻的感情基础并不牢固，或许女人是追求激情的动物，但是妻子的做法对丈夫也太过残忍了。同时，也为我敲响了警钟，当一个女人为了安稳生活的需要而组建家庭时，这种感情可谓苍白无力，根本无法抵挡真正的爱情的风暴。是的，爱情是冲动的热情。在这部作品中，没有所谓的好人有好报，戴尔克的善良和执着被贬得一无是处，或许这也是这本书被批三观不正的原因之一吧。\n\n斯特里特兰德辗转马赛、塔希提的经历让我部分扭转了对他的感受，他就是一个矛盾的综合体，你可以说他道德败坏，但是在一些人心中他就是那么与众不同，他坚忍，执着，不求名利，从不为外界改变自己的分毫。他将绘画作为宣泄情绪的唯一方式。画完一幅画，这幅画对他就不再有任何意义了。或许对于这种人，一个风景优美，荒无人烟的地方就是最适合他的。没错，塔希提就是这样一个地方。在这里他不必为复杂的人际关系所累，在热心的土著人的帮助下，他不必为生存而担忧。正如文中所说，塔希提就是他实际上的故乡，他漂泊半生走过一个又一个驿站，终于找到了自己精神的家园。\n\n![塔希提岛，最接近天堂的地方](http://picbed.erjiangao.com/img/20211009004814.jpeg)\n\n读这本书的时候，我在自己身上发现了一丝丝斯特里特兰德理想主义倾向和善良的施特略夫的影子。有些读者或许对施特略夫的行为不甚理解，但是于我则代入感很强，或许是个人感情经历的原因吧。本书阅毕我不禁在想一个人的成功究竟要如何评价？关键在于要活出自己的骄傲，可以像库特拉斯医生一样过着自食其力、简单淳朴的生活；也可以像斯特里特兰德那样，满地都是六便士，他却抬头看到了月亮。\n\n","tags":["阅读"]},{"title":"《人类简史》 - 尤瓦尔·赫拉利","url":"/2021/10/05/《人类简史》-尤瓦尔·赫拉利/","content":"\n真是一部不可多得的历史佳作！把从人类诞生到认知革命、农业革命、科技革命的历史浓缩到了不到30万字的书中，读过之后收益颇丰。\n\n智人作为一种物种好像并不那么特殊，史前曾经有多个人种存在于地球，尼安德特人比智人更耐寒，更为强壮；但智人好像又十分特殊，我们的祖先用语言和想象维系一个庞大的群体，创造出令人震撼的工具和文明，在多个人种同台亮相时占据着绝对优势，同时我们也给地球上的其他物种带来灭顶之灾。\n\n<!--more-->\n\n在谈到农业革命的时候，作者没有人云亦云，鼓吹农业革命的好处，而是从另一个视角切入，农业革命真的带给我们那么多好处吗？农业的确带给我们更多的粮食，但是同时也把人们拘束到了一个单一的地点，人们往往需要花上一整天的时间守在田里劳作，食品的多样性也大大降低。带来更多食品的同时也导致人口的大幅度增长。\n\n这本书科技革命部分主要讲述了帝国、科技革命与资本主义之间的关系，并且对三者之间的关系描述得十分精彩！让人忍不住赞叹资本主义商业模式这一天才的发明，但同时也初窥到资本主义模式下，商人为了利益剥削劳动者的本质。一切都是生意，还有什么不能当做商品，不能用于投资盈利呢？\n\n在我印象中初中高中的历史书只有史实的罗列，但是对于各个主体之间的关系描述甚少，我真的希望我在初中高中学历史的时候能有这本书。（哈哈，但是说不定即使有这本书我也不一定会读。对历史感兴趣与喜不喜欢上历史课是两码事，与考历史能不能拿高分又是两码事）\n","tags":["阅读"]},{"title":"The Old Man and the Sea - Ernest Hemingway","url":"/2021/09/07/The-Old-Man-and-the-Sea-Ernest-Hemingway/","content":"\nA little bit ashamed, this is the very first book written in English I have completely finished. And there is a long way to go as an English learner. Reading English original work might be a good way. When I started to read this book, it is sort of hard to fully comprehend. But later, I found that there was no need to understand the meaning of each word. Just knowing the general meaning is enough, otherwise it would take too much time to look up vocabulary. But still I spent six and a half hours in reading it. What's more, the writing style of Hemingway is really impressive. And his words are very straightforward and powerful, and hit the soul through monologue description. \n\n<!--more-->\n\nThe story of the old and the sea is so famous that I have already heard most of the plots in the book. However, I was still shocked by the spirit of the old man. The old man fought with the huge marlin for three days and was attacked by sharks for numerous times until there was no fresh in the skeleton. We have to admit that everyone in the world has limitation, although strong as the old man, he has his limitation that he cannot defeat the sharks. However, Does it mean people who did not overcome their limitations are failures? I don't think so. Because according to this kind of interpretation, people who don't try to get close to their limitations would never fail. So you might want to ask do you think that the old man succeeded? My answer is yes, I do think the old man succeeded. Success means a person fights to the end. The faith of the old man is undefeated. \n\nThank you the man for inspiring us all, and also thank you Hemingway. \n","tags":["阅读"]},{"title":"《沉默的大多数》 - 王小波","url":"/2021/08/31/《沉默的大多数》-王小波/","content":"\n这是我看的小波的第一本书。小波的杂文给我印象就是直言不讳，很多埋藏在国人心中的想法被表达了出来，这势必会遭到部分保守主义的反对，但是为了让中国的读书人有更加清醒的认知以及独立思考，小波这次选择了在沉默的大多数中站出来发声；并不是让我们全盘接受西方的模式，而是让我们看清楚自己思想上的欠缺。我感觉在当下，表面爱国主义情绪暴涨（尤其是想B站这种低龄化网站，容易被带节奏），但是缺乏更多的理性思考，这本书尤其值得一读。\n\n<!--more-->\n\n另外，让我印象非常深刻的一篇文章，海明威的《老人与海》，虽然听过无数次这本小说的内容，但是小波的解读直击内心深处，老人的抗争精神，让我不禁潸然泪下。老人从没有放下手中的武器，继续向限度斗争，战斗到最后一刻。我佩服老人的勇气，也佩服王小波的直言不讳。\n","tags":["阅读"]},{"title":"《人生的智慧》 - 叔本华","url":"/2021/08/08/《人生的智慧》-叔本华/","content":"\n很薄的一本书，但却蕴含着人生的智慧。读哲学家写的书很不一样的一点是他们总是想通过逻辑推理去证明一件事。读这本前两章的时候真的能给我带来一种平静的感觉，我们这一生过得是否幸福其实不取决于除自己内心感受之外的任何事物。尽管人的本性是很难改变的，但是应该尽力改善自己看待世界的想法。不同的人对待同一件事的看法不一样，为什么不朝着乐观的方向看呢？\n\n至于本书的后两章，可能是自己涉世未深，还不能引起我很大的共鸣，对于其中的一些观点也存在着不同的看法。或许就像作者在文中表达的，哲学家的书往往是在作者死后才拥有名声，因为普通人无法理会其中的深意。\n\n总之，这是一本告诉世人什么是重要的书，就好像在听一个怪脾气的老先生把他一生的经验告诉自己一样。\n","tags":["阅读"]},{"title":"《马克思传》 - 张光明，罗传芳","url":"/2021/08/05/《马克思传》-张光明，罗传芳/","content":"\n走过卡尔马克思的一生，真的为这位伟人人格的光辉所打动。他曾在1835年中学毕业时写下《青年在选择职业时的考虑》。说起来容易，做起来难，但是他做到了。他整个一生都在为人类的福祉而奔波，一生饱受颠沛流离之苦，但他初心不变，矢志不渝。他是顶天立地的伟人，他的事业鼓舞着成千上万人为人类的解放而斗争！\n\n我曾经在学校读过英语世界权威麦克劳伦的《马克思传》，感觉跟文件腔太重，读完第一章就没往下读了。感谢张光明，罗传芳两位作者，以中国人人的视角和表达方式，把马克思这位历史人物生动地呈现到我们眼前。\n","tags":["阅读"]},{"title":"Web开发技术后端重点复习","url":"/2021/03/23/Web开发技术后端重点复习/","content":"\n<pre>文：高尔健          校对：波哥</pre>\n\nweb开发这门课把web应用开发，从前端到后端到MVC设计模式讲了一遍，私以为这门课可以以MVC设计模式为骨架对系统开发中所有知识进行串讲，下面开始吧 ~\n\n## MVC设计模式\n\n### 客户端发送请求\n\n> MVC各部分的功能一会儿展开，你应该很熟悉了，带你串一下过程。\n\n首先，用户通过浏览器（对于咱们来说通常是）对服务器也就是**控制层**发出一个请求。如果是通过浏览器发出请求的话，可以是通过浏览器的地址栏，也可以是通过浏览器显示出的页面信息与后台进行互交，例如点击Button传递一个表单等也是发送请求。\n\n<!--more-->\n\n用户发出请求的类型有两种，get和post。如果是通过地址栏发出请求的话，就是通过输入URL（通用资源定位符），按下回车后，浏览器向后台发送了一个**get**请求。其实这么一想大部分的请求都是get请求，post请求主要是在向后台发送表单信息的时候使用。\n\n顺便说一下，URL是互联网上标准资源的地址，由三部分组成，分别是前缀（请求协议类型，例https），主机名（请求地址与端口，例`www.baidu.com:443`，http默认开放80端口，https默认开放443端口）和路径（服务器上层次目录结构中的文件，例：`/WebExamples/helloworld.html`）。\n\n请求是通过基于TCP/IP协议的http协议传输的，简单复习一下OSI计算机网络七层架构吧，分别是物理层physical、数据链路层data link、网络层network、传输层transport、会话层session、表示层presentation、应用层application。http属于应用层协议，TCP和IP分属传输层和网络层。另外通过http传输的信息都是字符串格式。\n\n### 控制层接收请求\n\n用户通过http协议将请求发送至web服务器，web服务器里有个web组件叫web container（如果是java EE开发的话，也可以叫servlet container，容器）。容器里的servlet是一个web组件，它的功能是接收用户（客户端、client或者浏览器）的请求，可能是get可能是post，对用户传递过来的信息进行接收。\n\n每当用户发送一个请求，由容器负责创建一个线程（通过线程池）处理用户的请求将用户的请求发送给servlet，线程比进程更轻量化，线程之间共享公共的内存空间，通信更加方便。\n\n你可能会问，我知道post请求发过来的是表单信息，那get请求发的是什么信息？答案是get请求可以在地址中携带信息，例如 `/examples?id=1`，这里get传递的信息以键值对的方式传递，servlet组件可以接收传递过来的信息，并进行解析或者校验。为什么要解析和校验？因为网络中信息以字符串的形式传递，所以后台接收到信息后需要进行类型转换，例如这个例子中就需要将id值为1这个信息提取出来，从字符串类型转换为整型（类型转换），并保存到变量里（封装），以便使用。但是谁知道用户发过来的数据是不是合法的，前端或许会对数据进行校验，但只是为了提供一种良好的互交体验，用户可以直接跳过前端向后端发送请求，所以后端一定要对数据进行校验（校验）。java定义了HttpServletRequest这个接口，`getParameter()`为其中一个方法，可以通过使用`req.getParameter()`方法获取请求中传递的参数，这个方法由容器实现，不同容器有不同的实现。\n\n再讲讲Servlet的功能的实现，首先javax下有个包servlet(javax.servlet)，这个包包含了servlet的API，这个包中的接口和类是协议无关的，而这个包中的http包(javax.servlet.http)中的接口和类是只对http请求负责的API。\n\njavax.servlet包中的Servlet接口定义了网络协议无关的servlet3个生命周期回调方法（`init()、service()、destroy()`）。\n\n- 如果是servlet的首次请求，则由容器创建servlet对象，并回调init()方法\n- 然后基于请求类型post/get回调service()方法，service()方法会将请求转发给相应的servlet对象，之后的请求直接回调service()方法，同一servlet可以对多个请求进行处理。\n\n下图为Servlet接口定义\n\n![image-20210323170649161](https://picbed.erjiangao.com/img/image-20210323182547642.png)\n\n接口需要实现，javax.servlet.GenericServlet实现了Servlet接口，HttpServlet抽象类继承自GenericServlet类，并重写了service()方法完成请求的转发，定义了处理http请求的方法（doGet()与doPost()）。\n\n说到这里你可能已经发现了，Servlet就是MVC中的控制层。所以当我们想要实现自己的控制层完成应用流程的操作的时候就可以自定义一个Servlet类，继承自HttpServlet类，基于具体请求逻辑重写请求方法（doGet()与doPost()）。Servlet接收用户请求后，需要对数据进行处理。对数据进行变更后需要将变更同步到数据库，但是与数据库的同步并不是servlet完成的，而是在控制层调用model层方法实现的。这么做的好处就是可以将应用程序的执行流程与具体业务逻辑操作（增删改查）分离。控制层不关心具体的业务逻辑如何实现。\n\n### model层处理业务逻辑、进行持久化操作\n\n控制层在调用model方法的时候，可能会将数据传递给model，例如删除一个学生，就需要调用model中的删除方法，将学生的学号传递给model。model接收到controller的数据后与数据库进行互交，完成对数据库的增删改查操作。当然，model也会将数据传递给控制层，例如当controller执行查询操作后。\n\n说一下JDBC，JDBC是java提供的访问基于SQL标准数据库的规范。这是一个面向接口编程的典型的例子，市面上有很多数据库，例如MySQL、Oracle，java为数据库制定了JDBC接口，各数据库只需要根据接口进行实现，即可完成与数据库的互交。这么做降低了数据库开发、维护、迁移的成本，当数据库变更的时候，只需要更换JDBC实现库即可。使用JDBC可以实现将SQL硬编码写在java程序中，性能良好，毕竟是直接与数据库进行互交，但缺点是不利于维护。\n\n> 这里多说几句，做web开发技术那门课最后的大作业的时候，有一次JDBC与数据库的互交出现问题，我花了好长时间排错，最后发现是业务逻辑层里SQL的代码中有一个单词拼错了，由于是硬编码，所以IDE根本不会给我什么错误提示，欲哭无泪。\n\nJDBC通过DataSource这个接口与目标数据源进行连接。DataSource使用独立文件（webapp下创建/META-INF/目录，创建context.xml文件，添加Resource资源配置）配置数据源信息，实现了数据源信息与连接获取行为的分离。容器在启动应用时扫描`@WebServlet` `@WebListener`注解，创建监听器获取DataSource对象（数据源对象需与应用生命周期绑定，因为数据库操作贯穿整个应用的生命周期）。同时容器将DataSource对象注册到JDNI树，容器提供数据库连接池，应用通过`@Resource`注解从JNDI树自动获取指定名称的DataSource对象并从连接池中获取连接对象，当连接使用完毕返还给连接池复用。\n\nmodel与数据库的时候主要使用了三个对象 Connection Statement ResultSet。\n\n- **连接对象**（connection）是应用、数据库数据互交的管道，在连接中执行SQL语句，获取返回结果等。\n\n- 刚才说在使用JDBC的时候可以在java程序里面写SQL语句，就是使用Statement创建SQL语句，通过连接发送至数据库，数据库进行语句的编译执行，数据库不缓存编译结果。还有一种互交的方式是**预编译的Statement**（PreparedStatement语句里面预留参数位置，例如 `SELECT * FROM USER WHERE id=?`），发送预编译的SQL语句到数据库，数据库进行编译并缓存编译结果，之后只需要传递参数给预编译的SQL语句，然后执行更新或者查询（`preparedStatement.executeUpdate();`），这种写法效率更高。\n\n- 执行数据库查询后的结果可以使用**ResultSet**这个数据结构来接收结果，它的next()方法可以将返回的数据记录按行读取。\n\n另外必须按照Connection Statement ResultSet这个顺序创建和逆向关闭以上资源对象，Java提供了自动关闭资源的方法，即将声明写在try语句里，下面举个栗子。\n\n```java\n// 定义需要自动关闭的连接对象与预编译语句对象在try的括号里\ntry (Connection connection = DataSourceUtils.getConnection();\n   PreparedStatement st = connection.preparedStatement(sql)) {\n\t// 将参数传递给第一个占位符\n    st.setString(1, name);\n    // 执行更新\n    st.excuteUpdate();\n} catch (SQLException e) {\n    // ...\n}\n```\n\n当model层接收到数据库的数据库可以将数据库进行封装，并将封装后的数据返回控制层。\n\n### 再回到控制层\n\n控制层继续像上一节一样调用其他的model方法完成应用流程操作。控制层对用户请求的响应可以分成两种，分别是重定向和请求转发。\n\n- 重定向本质就是服务端给客户端一个响应，要求客户端对一个新的地址发起get请求，客户端接收到服务端的响应，发起一个新的get请求，此时浏览器地址栏会改变。例子：未登录的用户请求访问应用的欢迎界面（/welcome），被控制层拦截（其实应该由拦截器Filter拦截）重定向到登录界面（/login）。\n\n- 请求转发就是将请求数据传递到服务器类任何其他资源（JSP页面、HTML），这里servlet将请求和响应传递给视图层，通过HttpServletRequest对象（由容器注入）的getRequestDispatcher()方法创建一个封装了指定资源的RequestDispatcher对象，通过对象的forward()方法，传递请求响应对象到指定资源，下图是一个例子。\n\n  ![image-20210323182547642](https://picbed.erjiangao.com/img/image-20210323182547642.png)\n\n那么我现在已经知道了servlet可以将请求和响应传递给视图层，那么数据是怎么传递的呢？答：通过对象的setAttribute()方法实现，通过此方法可以以键值对的方式放入任意对象。同时还可以设置不同的作用域对象，例如Session对象，就在浏览器关闭的时候才销毁，创建方式如下。\n\n```java\n// request级，生命周期随request对象的销毁而销毁，只在一次请求内有效\nreq.setAttribute(\"requestScope\", \"request级作用域\");\n// session级，整个会话内有效\nHttpSession session = req.getSession();\nsession.setAttribute(\"sessionScope\", \"session会话级作用域\");\n```\n\n### 视图层显示页面信息\n\n刚才没有提到，利用servlet我们可以其实已经可以通过PrintWriter对象实现java和HTML的互交，但是需要在java程序中对html硬编码，可行性很差，所以我们需要用到JSP（java server pages）、EL（Expression Language）、JSTL（Java Standard Tag Library）与html进行互交。\n\nJSP是一种以java语言为脚本语言，运行在服务器端的技术，我们使用JSP以html为基础构件显示逻辑，创建动态的页面。JSP支持直接获取上一节提到的存储在请求、响应以及会话对象，使用存储其中的数据。例如通过EL表达式查找相应名称的对象`${name}`（这个例子中name这个属性是request作用域下的）。\n\nJSP页面必须由服务器端编译运行，客户端无法直接运行，因为JSP页面的本质是抽象的Servlet，运行时由服务器动态生成相应的Servlet。JSP被转为servlet后，底层通过PrintWrite动态生成html代码，服务端将浏览器可以理解的信息（html css js 资源等）传递给客户端，由浏览器渲染后向用户显示信息，用户基于显示的内容完成下一轮请求，完事 ~\n\n<pre>引用：波哥web开发技术PPT</pre>\n\n**the end**","tags":["web开发技术"]},{"title":"java数据结构 -- 优先队列","url":"/2020/07/07/java数据结构-优先队列/","content":"\n## Java Priority Queue 类\n\nQueue是一个严格的先进先出的数据结构，那么如果我们想让队列中的元素有优先级应该怎么办呢？答案就是使用优先队列，让队列中的元素存在优先级，每次出队的时候都是优先级最高的元素出队。Priority Queue其实本质上是一个堆，当没有指定Comparator时默认为小根堆。\n\n<!--more-->\n\n放入`PriorityQueue`的元素，必须实现`Comparable`接口，`PriorityQueue`会根据元素的排序顺序决定出队的优先级。此实现提供了O（日志（n））的时间入队和出队方法（ `offer` ， `poll` ， `remove()`和`add` ）; 线性时间为`remove(Object)`和`contains(Object)`方法; 和恒定时间检索方法（ `peek` ， `element` ，和`size` ）。\n\n| 变量和类型              | 方法                                    | 描述                                                         |\n| :---------------------- | :-------------------------------------- | :----------------------------------------------------------- |\n| `boolean`               | `add(E e)`                              | 将指定的元素插入此优先级队列。                               |\n| `void`                  | `clear()`                               | 从此优先级队列中删除所有元素。                               |\n| `Comparator<? super E>` | `comparator()`                          | 返回用于为了在这个队列中的元素，或比较`null`如果此队列根据所述排序[natural ordering](https://www.apiref.com/java11-zh/java.base/java/lang/Comparable.html)的元素。 |\n| `boolean`               | `contains(Object o)`                    | 如果此队列包含指定的元素，则返回 `true` 。                   |\n| `void`                  | `forEach(Consumer<? super E> action)`   | 对 `Iterable`每个元素执行给定操作，直到处理 `Iterable`所有元素或操作引发异常。 |\n| `Iterator<E>`           | `iterator()`                            | 返回此队列中元素的迭代器。                                   |\n| `boolean`               | `offer(E e)`                            | 将指定的元素插入此优先级队列。                               |\n| `boolean`               | `remove(Object o)`                      | 从此队列中删除指定元素的单个实例（如果存在）。               |\n| `boolean`               | `removeAll(Collection<?> c)`            | 删除此集合的所有元素，这些元素也包含在指定的集合中（可选操作）。 |\n| `boolean`               | `removeIf(Predicate<? super E> filter)` | 删除此集合中满足给定谓词的所有元素。                         |\n| `boolean`               | `retainAll(Collection<?> c)`            | 仅保留此集合中包含在指定集合中的元素（可选操作）。           |\n| `Spliterator<E>`        | `spliterator()`                         | 在此队列中的元素上创建*[late-binding](https://www.apiref.com/java11-zh/java.base/java/util/Spliterator.html#binding)*和*故障快速* [`Spliterator`](https://www.apiref.com/java11-zh/java.base/java/util/Spliterator.html) 。 |\n| `Object[]`              | `toArray()`                             | 返回包含此队列中所有元素的数组。                             |\n| `<T> T[]`               | `toArray(T[] a)`                        | 返回包含此队列中所有元素的数组; 返回数组的运行时类型是指定数组的运行时类型。 |\n\n> 注意：不允许使用null类。\n\n## 例题\n\n力扣 [23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)\n\n","tags":["数据结构"]},{"title":"类加载器与双亲委派机制（JVM入门学习三）","url":"/2020/07/04/双亲委派机制/","content":"\n## 类加载器\n\n**作用**\n\n加载Class文件为类。\n\n实例化：`new`\n\n获取类：`.getClass()`\n\n获取类加载器：`.getClassLoader()`\n\n**分类**\n\n1. 虚拟机自带的加载器\n2. 启动类（根）加载器\n3. 扩展类加载器\n4. 应用程序（系统类）加载器\n\n<!--more-->\n\n## 双亲委派机制\n\n保证安全，防止修改重写JVM代码。\n\nAPP -> EXC(扩展类加载器) -> BOOT(根加载器)\n\nJava程序执行的时候先到根加载器，看能不能执行\n\n1. 类加载器收到类加载的请求 Application\n2. 将这个请求向上委托给父类加载器完成，一直向上委托，直到启动类加载器\n3. 启动类加载器检查是否能够加载当前这个类，能加载就使用当前的加载器，否则抛出异常，通知子加载器进行加载\n4. 重复步骤3\n\n**null的情况**\n\njava调用不到，有可能是用C、C++编写的程序（native 方法调用本地方法）\n\nJava = C++--：去掉繁琐的东西，指针，内存管理\n\n>  JNI: Java本地接口","tags":["JVM"]},{"title":"JVM体系结构（JVM入门学习二）","url":"/2020/07/04/JVM体系结构/","content":"\n**JVM在计算机中的位置**\n\n![](http://picbed.erjiangao.com/img/image-20200704154751975.png)\n\n<!--more-->\n\n**JVM体系结构**\n\n![](http://picbed.erjiangao.com/img/image-20200704170903307.png)\n\n\n**垃圾回收**\n\n堆里面肯定有垃圾，栈里面肯定不会存在垃圾。\n\n99%的JVM调优都是调堆。","tags":["JVM"]},{"title":"软件项目管理知识点总结（8 - 17章）","url":"/2020/07/02/软件项目管理期末复习/","content":"\n### 第八章\n\n**软件质量管理过程**\n\n1. 软件**质量计划**：提出要求\n\n   1.  实验设计\n   2.  基准对照\n   3.  质量成本分析\n   4.  流程图方法\n   5.  因果图方法\n\n2. 软件**质量保证**：通过评价项目整体绩效，建立对质量要求的信任\n\n   质量保证活动——**审计**：是对过程或者产品的一次独立评估\n\n   1. 项目执行过程审计\n      1. 需求过程\n      2. 设计过程\n      3. 编码过程\n   2. 项目产品审计\n\n3. 软件**质量控制**：确定项目结果与质量标准是否项目，同时，确定消除不符的原因和方法\n\n   **质量控制活动**：\n\n   1. 技术评审\n   2. 代码走查\n   3. 软件测试\n   4. 返工\n\n<!--more-->\n\n**说出三种质量模型及其主要组成部分**\n\n1. Boehm质量模型\n   1. 软件的可使用性\n   2. 软件的可移植性\n   3. 可维护性\n2. McCall质量模型\n   1. 产品修改\n   2. 产品转移\n   3. 产品运行\n3. ISO模型\n   1. 质量特性\n   2. 质量子特征\n   3. 度量因子\n\n**质量保证与质量控制的关系：**\n\n质量控制QC：前期质量活动。是通过评价项目整体绩效,建立对质量要求的信任，提供项目和产品可视化的管理报告。这个任务本身并不能提高产品的质量，但是通过质量保证的一系列工作可以间接地提高产品的质量。质量保证一般由质量保证部门人员实施。\n\n质量保证QA：后期质量活动。是确定项目结果与质量标准是否相符,同时,确定消除不符的原因和方法，它控制产品的质量，及时纠正缺陷。这个任务本身提高产品的质量，一般由开发人员实施。\n\n质量保证是针对项目实施过程的管理手段，质量控制是针对项目产品的技术手段;实施质量保证是针对过程改进和审计的，强调的是过程改进和信心保证。实施质量控制是按照质量要求，检查具体可交付成果的质量，强调的是具体的可交付成果。\n\n**质量成本**\n\n1. 预防成本\n2. 缺陷成本\n\n### 第九章\n\n**基线的含义**\n\n基线提供了软件生存期中各个开发阶段的一个特定点，一个里程碑\n\n**软件配置控制委员会的基本职责是什么？**\n\n1. 评估变更\n2. 批准变更申请\n3. 在生存期内规范变更申请流程\n4. 对变更进行反馈\n5. 与项目管理层沟通\n\n**配置管理的基本过程**\n\n1. 配置项的标志、跟踪：建立配置项的对应关系\n2. 配置管理环境建立\n3. 基线变更管理过程\n   1. 基线修改应受到控制，按程序进行控制并记录基线修改的过程\n   2. 过程：变更请求、变更评估、变更批准/拒绝、变更实现\n4. 配置管理审计：确保变更需求已被实现\n5. 配置状态统计：检查配置管理系统及其内容\n\n**软件配置管理的核心功能和主要功能是什么**\n\n核心：版本控制\n\n主要：版本管理、变更管理\n\n**配置管理SCM最终保证软件的什么性质**\n\n1. 完整性\n2. 一致性\n3. 追溯性\n4. 可控性\n\n**变更控制主要关注的是**\n\n1. 标志变更\n2. 提出变更\n3. 管理变更\n\n**说出常见的几个配置项**\n\n1. 用户需求说明书\n2. 体系结构设计报告\n3. 数据库设计报告\n4. 模块设计报告\n5. 用户界面设计报告\n6. 软件源代码\n7. 二进制库\n8. 测试报告\n9. 测试用例\n\n\n\n### 第十章\n\n**沟通管理的基本原则**\n\n1. 及时性\n2. 准确性\n3. 完整性\n4. 可理解性\n\n**写出5种沟通方式**\n\n1. 书面沟通、口头沟通\n2. 正式沟通、非正式沟通\n3. 单向沟通、双向沟通、网络沟通\n4. 语言沟通、非语言沟通\n\n**干系人的几种态度**\n\n1. 完全不支持\n2. 反对\n3. 不积极\n4. 无所谓\n5. 参与\n6. 较积极\n7. 内部支持者\n8. 首倡者\n9. 完全支持\n\n**矩阵型的组织结构的优缺点**\n\n\n\n### 第十一章\n\n**风险计划三要素**\n\n1. 一个事件\n2. 事件发生的概率\n3. 事件的影响\n\n**风险管理的四个过程**\n\n1. 风险识别\n2. 风险评估：定性、定量\n3. **风险规划**\n4. 风险控制\n\n**风险规划的主要策略**\n\n1. 回避风险\n2. 转移风险\n3. 损失控制\n4. 自留风险\n\n**项目风险的识别常采用**\n\n1. 德尔菲方法\n2. 头脑风暴\n3. 情景分析\n4. 风险条目检查\n5. 其他\n\n### 第十二章\n\n**合同的类型**\n\n1. 成本补偿合同\n\n   1. 成本加成本百分比 CPPC\n\n   2. 成本加固定费用 CPFF\n\n   3. 成本加奖金 CPIF\n\n      在成本的基础上加上利润加一定的奖励\n\n2. 固定价格合同\n\n   1. 固定价格加奖励费 FPIF\n\n      在CPIF的基础上固定最高价，如果大于目标成本则以最高价作为合同金额\n\n   2. 固定总价 FFP\n\n3. 单价合同\n\n   1. 一个产品或一个时间度量单位的价格\n\n**合同类型与风险**\n\n![image-20200701230559117](http://picbed.erjiangao.com/img/image-20200701230559117.png)\n\n### 第十三章 项目集成计划\n\n**软件项目管理最重要四个要素**\n\n1. 范围\n2. 质量\n3. 进度\n4. 成本\n\n**成本或时间不足时，可以通过什么方法解决**\n\n1. 减小范围\n2. 降低质量\n\n### 第十四章 项目集成计划执行控制\n\n**描述项目执行控制的步骤**\n\n1. 建立计划标准\n2. 观察项目性能\n3. 测量分析结果\n4. 采取表要措施\n5. 做好计划修订工作，控制反馈\n\n### 第十五章\n\n**挣值分析输入**\n\n| 输入 | 含义                   |\n| ---- | ---------------------- |\n| BAC  | 总预算成本             |\n| TAC  | 计划完成时间           |\n| BCWS | 计划完成工作的预算成本 |\n| ACWP | 已完成工作的实际成本   |\n| BCWP | 已完成工作的预算成本   |\n\n**挣值分析输出**\n\n| 输出 | 含义                                    |\n| ---- | --------------------------------------- |\n| SV   | BCWP - BCWS 进度差异                    |\n| CV   | BCWP - ACWP 成本差异                    |\n| SPI  | BCWP / BCWS 进度效能指标                |\n| CPI  | BCWP / ACWP 成本效能指标                |\n| EAC  | BAC / CPI 预测项目完成成本              |\n| SAC  | TAC / SPI 预测项目完成时间              |\n| VAC  | BAC - EAC 项目完成的成本差异            |\n| TCPI | (BAC - BCWP) / (Goal - ACWP) 未完工指数 |\n\n除了TCPI所有的输出都是越小越不好\n\n如果TCPI大于1，则将来必须做的比计划好才能达到项目目标\n\n**BCWP的计算**\n\n1. 50/50\n2. 1/100\n3. 经验加权\n\n**质量执行控制包括那两方面**\n\n1. 质量保证\n2. 质量控制\n\n**缺陷图法反应什么**\n\n软件产品的质量随着时间变化的情况\n\n### 第十六章\n\n**人员的计划执行控制都有哪些**\n\n1. 团队建设\n2. 人员培训\n3. 人员激励\n\n**项目培训的特点有哪些**\n\n1. 短期\n2. 片段式\n3. 针对性强\n4. 见效快\n\n**说出几种项目成员的激励理论**\n\n1. 马斯洛需求理论\n2. 海兹伯格激励理论\n3. 麦克勒格的X-理论 Y-理论\n4. 超Y理论\n5. Z理论\n6. 期望理论\n\n**冲突的解决方法**\n\n1. 撤退\n2. 强迫方式\n3. 妥协\n4. 解决问题\n\n### 第十七章\n\n**项目终止的条件有哪些**\n\n1. 项目计划中确定的可交付成果已经出现\n2. 由于相关原因，项目无法继续进行\n\n**简述项目结束的过程**\n\n1. 项目验收\n2. 合同终止\n3. 项目最后评审\n4. 项目总结报告\n\n","tags":["软件工程"]},{"title":"微服务架构持续集成、交付、部署完整流程示例","url":"/2020/06/21/微服务架构持续集成、交付、部署完整流程示例/","content":"\n## 预备知识\n\n本示例以我今年完成的一个[实现师生互选的项目（点击访问）](https://github.com/ErjianGao/tutor-selection-tool)为基础，演示`Spring Boot + MySQL + Vue`的CI/CD的完整流程，旨在介绍具体的步骤，不包含很多理论知识，开始之前你最好掌握以下预备知识~\n\n- [docker基础知识](https://docs.docker.com/)\n- [微服务框架基础知识](http://dockone.io/article/3687)\n- [持续集成、交付、部署的基本思想](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n\n## 所需工具\n\n- docker\n- docker-compose\n- GitHub repository\n- GitHub actions workflow\n- GitHub package\n\n<!--more-->\n\n## 流程\n\n### 申请GitHub公共仓库\n\n这一步比较简单，直接在GitHub网站申请即可，将代码提交到GitHub仓库中，不再赘述。\n\n### 持续集成\n\n#### 定义GitHub actions workflow\n\nGithub actions是一套工作流，基于脚本执行操作。\n\n在仓库首页点击Actions\n\n![](http://picbed.erjiangao.com/img/20200622012410.png)\n\n\n\n首先配置后端，由于我们的Spring Boot项目是通过Maven构件的，所以选择Maven模板工作流。\n\n![](http://picbed.erjiangao.com/img/20200622012501.png)\n\nGitHub会自动生成在项目的`.github/workflow`生成了一个yaml类型的脚本，通过编写此脚本定义工作流。脚本的部分参数说明如下：\n\n**maven.yml**\n\n```yaml\n# This workflow will build a Java project with Maven\n# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven\n\n# 工作流名称\nname: Java CI with Maven\n\n# 监听\non:\n  # 当向master分支push操作的时候执行操作\n  push:\n    # 分支列表\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  # 持续集成\n  build:\n    # 指定操作系统（自动生成），在ubuntu上执行下列操作\n    runs-on: ubuntu-latest\n    steps:\n      # 将步骤暴露出去为actions，类似于发布出去，让别人调用，这是GitHub提供的actions，只要一执行use就会执行一系列操作，此步是将仓库中的源码提取出来，并不需要关心位置\n      - uses: actions/checkout@v2\n      # 声明步骤名称\n      - name: Set up JDK 11\n        # 把ubuntu中的jdk版本设为11\n        uses: actions/setup-java@v1\n        # 参数赋给上边的use\n        with:\n          java-version: 11\n      - name: Build with Maven\n        # 由GitHub提供的服务器进行构建、打包，单元测试中涉及到数据库的操作，所以单元测试不会通过，应该声明跳过单元测试，或者直接在gitignore中把测试的代码忽略\n        run: mvn package -DskipTests\n\n```\n\n前端的持续集成与后端基本相同，只需选取node.js的工作流模板进行编写即可。\n\n![](http://picbed.erjiangao.com/img/20200622012550.png)\n\n前端的`workflow`定义如下。\n\n**node.js.yml**\n\n```yaml\nname: Node.js CI\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Use Node.js '12.x'\n      uses: actions/setup-node@v1\n      with:\n        node-version: ${{ matrix.node-version }}\n    - run: npm ci\n    - run: npm run build --if-present\n    - run: npm test\n```\n\n到此可以完成项目后端的持续集成，每次`push`或`pull request`之后GitHub工作流会将代码仓库中的代码提取出来进行测试和打包。\n\n### 持续交付\n\n代码推送后，我们需要系统根据定义好的Docker file文件，构件docker镜像，并推送到某个镜像服务器（这里介绍Github package）中去，在工作流中添加step，登录GitHub镜像服务器，构建镜像，打标签，推送至镜像仓库。\n\n#### 定义Docker file\n\nDocker file应定义在项目的根目录下，这样在GitHub工作流工作时可以具有连贯性，docker可以直接基于当前位置（项目根目录）进行镜像的构件。\n\n**后端Spring Boot的Docker file**\n\n```dockerfile\n# 声明基础镜像\nFROM openjdk:11\n# 打包后在项目目录下，将编译后的jar包复制到容器指定位置\nCOPY ./target/*.jar /home/tutor-selection-tool.jar\n# 声明入口，运行容器后，运行java程序，加参数使用生产环境的配置\nENTRYPOINT java -jar /home/tutor-selection-tool.jar --spring.profiles.active=prod\n\n```\n\n**前端nginx的Docker file**\n\n```dockerfile\n# 基于最新版nginx创建\nFROM nginx:latest\n# 将nginx配置放到指定的位置\nCOPY mysite.template /etc/nginx/conf.d/mysite.template\n# 打完包后在项目下的dist拷贝到指定位置\nCOPY dist/ /usr/share/nginx/html/\n# 通过shell语句完成对nginx配置中变量的识别\nENTRYPOINT /bin/bash -c \"envsubst < /etc/nginx/conf.d/mysite.template > /etc/nginx/conf.d/default.conf && exec nginx -g 'daemon off;'\"\n```\n\n#### 定义项目配置文件\n\n**Spring boot使用生产环境下的配置，配置如下**\n\n**application.properties**\n\n```properties\n# 开发环境\nspring.profiles.active=dev\n\n```\n\napplication-prod.properites 中几个与生产环境中不同的配置如下所示，需要注意的是数据源的主机地址和端口号应该是部署的时候确定的，所以应该设置成变量，数据库的用户名和密码同理。\n\n**application-prod.properites**\n\n```properties\n########## datasource ##########\n# 如果数据库不存在则创建，生产环境下数据库端口使用变量，springboot自动在系统运行的环境变量中找变量\nspring.datasource.url=jdbc:mysql://${dhost}/tutor_selection_tool?createDatabaseIfNotExist=true\\\n  &serverTimezone=Asia/Shanghai\n# 现在建议使用密钥的方式，不易被破解\nspring.datasource.username=${dusername}\nspring.datasource.password=${dpassword}\n# MySQL8的驱动\nspring.datasource.driverClassName=com.mysql.cj.jdbc.Driver\n\n########## log ##########\nlogging.level.root=warn\n# 生产环境下使用info级\nlogging.level.com.erjiangao=info\n# 时间；日志级别；类；方法；行(行不能使用圆括号)\nlogging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} %-5level %C.%M[%line] - %msg%n\n\n```\n\n**nginx配置**\n\n这里只列举了最基本的nginx配置，详细配置可以参考[这篇文章](https://juejin.im/post/5c1616186fb9a049a42ef21d)\n\n**mysite.template**\n\n```nginx\nserver {\n    # 设定通过nginx上传文件的大小\n    client_max_body_size 0;\n    # 入口文件的设置\n    location / {\n        # 入口文件所在位置\n        root /usr/share/nginx/html;\n        index ${index};\n    }\n    # 反向代理设置\n    location /api/ {\n        # 完成反向代理，映射到后端\n        proxy_pass http://${backend};\n    }\n}\n\n```\n\n#### 登录docker镜像服务器\n\nGitHub package用于存储docker镜像，各大公司云服务同样可以实现此镜像管理功能，但是GitHub package是完全免费的。\n\n**创建用于命令行的个人访问令牌**\n\n如果用普通的密码登录，权限会受到限制，GitHub 提供一个令牌，可用于代表 GitHub 操作 进行身份验证。\n\nhttps://help.github.com/cn/github/authenticating-to-github/creating-a-personal-access-token-for-the-command-line\n\n![](http://picbed.erjiangao.com/img/20200622012624.png)\n\n该令牌一定要妥善保管，不能暴露出去！\n\n比较安全的做法是将令牌保存在文件中，然后用命令行进行docker login。\n\n```shell\n# Usage:  docker login [OPTIONS] [SERVER]\n$ cat ~/TOKEN.txt | docker login https://docker.pkg.github.com -u USERNAME --password-stdin\n```\n\n也可以使用命令行通过令牌直接登录\n\n```shell\n$ echo TOKEN | docker login https://docker.pkg.github.com -u USERNAME --password-stdin\n```\n\n**在项目的secrets中添加信息**\n\n由于GitHub TOKEN不能暴露在仓库里，所以在项目中添加Secrets变量，然后在workflow中使用`${screts.DOCKER_LOGIN}`这样的格式使用隐藏的变量进行docker登录。\n\n![](http://picbed.erjiangao.com/img/20200622012642.png)\n\n#### 在yaml中继续添加step，发布到镜像服务器\n\n> `docker build [OPTIONS] PATH | URL | -`\n> Build an image from a Dockerfile\n>\n> `docker push [OPTIONS] NAME[:TAG]`\n> Push an image or a repository to a registry\n\n**后端工作流maven.yml**\n\n```yaml\njobs:\n  # 持续集成\n  build:\n    # 指定操作系统（自动生成），在ubuntu上执行下列操作\n    runs-on: ubuntu-latest\n    steps:\n    \n      ...\n      \n      # 发布镜像\n      - name: push to package\n        run: |\n          # 使用个人令牌或密码进行docker登录\n          ${{ secrets.DOCKER_LOGIN }}\n          # 根据指定的目录内的Dockerfile进行构建，由于是当前目录，所以就是一个点，打标签 服务器/仓库/镜像:版本\n          docker build . -t docker.pkg.github.com/erjiangao/tutor-selection-tool/tutor-selection-tool:latest\n          # 将镜像推送到镜像服务器\n          docker push docker.pkg.github.com/erjiangao/tutor-selection-tool/tutor-selection-tool:latest\n          \n```\n\n**前端工作流node.js.yml**\n\n与后端写法一样\n\n```yaml\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    \n      ...\n      \n      run: |\n       ${{ secrets.DOCKER_LOGIN }}\n       docker build -t docker.pkg.github.com/erjiangao/tutor-selection-tool-vue/tutor-selection-tool-vue:latest .\n       docker push docker.pkg.github.com/erjiangao/tutor-selection-tool-vue/tutor-selection-tool-vue:latest\n```\n\n### 持续部署\n\n工作流程是需要先进入到项目部署服务器，然后从docker镜像服务器拉取镜像，根据提前放到项目根目录下的docker-compose.yml文件运行docker容器。\n\n#### 编写docker-compose文件\n\ndocker-compose是一个定义并运行docker容器的工具，使用docker compose可以方便的进行容器之间的编排，完成容器间互交，位置一般在部署服务的项目根目录下。详细介绍可以查阅[官方文档](https://docs.docker.com/compose/)。\n\n本项目一共定义了三个service，其中Spring Boot服务与Nginx服务会从持续部署中的docker镜像服务拉取最新镜像。定义桥接网络可以方便地实现服务间的互交，将三个容器放到同一个网络下即可。\n\n还有一个值得注意的点是可以通过声明`depends_on`来定义当前服务依赖于哪个服务，例如本项目中，Sping Boot服务依赖于数据库mysql服务，前端的nginx服务又依赖于Sping Boot服务。\n\n**项目结构**\n\n```\ntutor-selction-tool     \n├── docker-compose.yml\n├── mysql\n│   └── data    \n├── nginx\n└── openjdk \n```\n\n**docker-compose.yml**\n\n```yaml\n# 指定版本\nversion: '3.7'\n\nservices:\n  # 数据库服务\n  tutor-selection-tool-mysql:\n    # 容器命名\n    container_name: tutor-selection-tool-mysql\n    # 指定mysql官方镜像\n    image: mysql:8\n    # 数据挂载，宿主位置:容器位置，容器中的数据与宿主机的文件夹进行挂载，防止删除容器后数据丢失，或者当使用新的容器，想使用原来的数据时方便恢复，后面的容器的位置是官方定义的\n    volumes:\n      - ./mysql/data/:/var/lib/mysql/\n    # 声明网络\n    networks:\n      - spring-boot-mysql-nginx-network\n    # 环境变量，mysql要求提供，根据此密码可以进入容器mysql中\n    environment:\n      TZ: Asia/Shanghai\n      MYSQL_ROOT_PASSWORD: root\n\n  # Springboot服务\n  tutor-selection-tool-openjdk:\n    # 容器命名\n    container_name: tutor-selection-tool-openjdk\n    # 从GitHub package拉取镜像\n    image: docker.pkg.github.com/erjiangao/tutor-selection-tool/tutor-selection-tool:latest\n    networks:\n      - spring-boot-mysql-nginx-network\n    # 环境变量\n    environment:\n      # 从当前的网络中找指定主机端口\n      - dhost=tutor-selection-tool-mysql:3306\n      # 登录名密码\n      - dusername=root\n      - dpassword=root\n    # 将容器端口映射到宿主机端口，可以声明也可以不声明，一般情况下不会将后端端口直接暴露出去\n    ports:\n      - \"8080:8080\"\n    # 声明依赖于那个服务\n    depends_on:\n      - tutor-selection-tool-mysql\n  \n  # nginx服务\n  tutor-selection-tool-nginx:\n    image: docker.pkg.github.com/erjiangao/tutor-selection-tool-vue/tutor-selection-tool-vue:latest\n    networks:\n      - spring-boot-mysql-nginx-network\n    environment:\n      # 配置前端Nginx反向代理\n      - backend=tutor-selection-tool-openjdk:8080\n      # 配置入口文件\n      - index=index.html\n    # 向外暴露80端口\n    ports:\n      - \"80:80\"\n    depends_on:\n      - tutor-selection-tool-openjdk\n\n# 创建桥接网络，实现容器之间互交\nnetworks:\n  spring-boot-mysql-nginx-network:\n    driver: bridge\n\n```\n\ndocker-compose编写完成后需要放到服务器项目根目录下，我是先在本地完成了编写，然后使用xftp工具完成了传输。\n\n#### 继续编写workflow完成持续部署\n\n部署部分的工作流使用第三方提供的action，将服务器的用户名密码作为with参数完成登录部署服务器（这里服务器用户名密码当然也需要方法项目的Secrets里面），并使用docker-compose拉取镜像，运行容器，最后删除掉旧的docker镜像。\n\n> ```\n> Pulls images for services defined in a Compose file, but does not start the containers.\n> Usage: docker-compose pull [options] [SERVICE...]\n> \n> Builds, (re)creates, starts, and attaches to containers for a service.\n> Usage: docker-compose up [options] [--scale SERVICE=NUM...] [SERVICE...]\n> \n> Usage:\tdocker rmi [OPTIONS] IMAGE [IMAGE...]\n> Remove one or more images\n> ```\n\n**maven.yml**\n\n```yaml\njobs:\n  # 持续集成\n  build:\n    \n    ...\n    \n  # 持续部署\n  deploy:\n    # 需要build执行完才能执行部署\n    needs: [ build ]\n    runs-on: ubuntu-latest\n    steps:\n      - name: deploy\n        # 使用第三方提供的登录actions\n        uses: appleboy/ssh-action@master\n        # 登录需要的参数\n        with:\n          host: ${{ secrets.SERVER_HOST }}\n          username: ${{ secrets.SERVER_USERNAME }}\n          password: ${{ secrets.SERVER_PASSWORD }}\n          # 登录后执行命令\n          script: |\n            # 进入到项目文件夹中\n            cd /home/erjiangao/services/tutor-selection-tool\n            # 重新基于docker-compose.yml拉取镜像\n            docker-compose pull\n            # 如果文件名不叫docker-compose.yml，则加-f参数，基于指定文件执行后台启动\n            docker-compose up -d\n            # “&&”这种写法的目的是先判断一下当前仓库里有没有标签为<none>的镜像，如果有的话，继续执行镜像删除语句，如果没有的话，则直接跳过跳过删除语句，防止删除\n            [ $(docker images -f dangling=true docker.pkg.github.com/erjiangao/tutor-selection-tool/tutor-selection-tool -q) ] && \\\n            # 删除多余镜像\n            docker rmi $(docker images -f dangling=true docker.pkg.github.com/erjiangao/tutor-selection-tool/tutor-selection-tool -q)\n\n```\n\n**node.js.yml**\n\n前端部署脚本与后端基本相同\n\n```yaml\njobs:\n  build:\n\n    ...\n        \n  deploy:\n    needs: [ build ]\n    runs-on: ubuntu-latest\n    steps:\n    - name: deploy\n      uses: appleboy/ssh-action@master\n      with:\n        host: ${{ secrets.SERVER_HOST }}\n        username: ${{ secrets.SERVER_USERNAME }}\n        password: ${{ secrets.SERVER_PASSWORD }}\n        script: |\n          ${{ secrets.DOCKER_LOGIN }}\n          cd /home/erjiangao/services/tutor-selection-tool/\n          docker-compose up -d\n          [ $(docker images -f dangling=true docker.pkg.github.com/erjiangao/tutor-selection-tool-vue/tutor-selection-tool-vue -q) ] && \\\n           docker rmi $(docker images -f dangling=true docker.pkg.github.com/erjiangao/tutor-selection-tool-vue/tutor-selection-tool-vue -q)\n\n```\n\n到这里基于GitHub Actions Workflow的持续集成、交付、部署就已经定义好了，接下来每当push或者pull request到代码仓库时就会激活工作流自动完成一个CI/CD的流程。登录服务器查看一下docker容器的状态，如下。\n\n![](http://picbed.erjiangao.com/img/20200622012749.png)\n\n快去试试吧~","tags":["web开发技术","项目"]},{"title":"归并排序与快速排序的区别","url":"/2020/03/29/归并排序与快速排序的区别/","content":"\n归并排序与快速排序一样，都是采用了分治的思路，将一个问题分成两个子问题，即分成两个子数组分别进行排序。不同的是，快速排序在将数组分成两部分的时候保证左半部分的数组元素一定小于右半部分，归并排序在分裂的时候不对数组进行处理，直接将数组等分（数量差小于等于1），而后在回溯时对两数组进行归并。\n\n换句话说，快速排序对数据的处理是在递归调用之前，而归并排序是在递归调用之后。","tags":["算法"]},{"title":"归并排序算法","url":"/2020/03/29/归并排序算法/","content":"\n# Merge Sort\n\n归并排序采用了分治的思路，可以使用递归实现，先将数组均分为两份（数量小于等于1），对每一份继续调用递归函数`mergeSort`，当结点为叶子结点时直接返回，此时已经到达递归的树的最低端，开始进行回溯，也就是归并`merge`。\n\n将两个数组进行归并的方法是设置两个游标，和一个辅助数组（可以设置为全局变量），先将待归并的两个数组存到辅助数组中，然后对两个数组的元素逐一进行比对，将较小的元素值存到原数组中，当前元素的游标移动一位，当两个游标扫描完两个数组后，归并完成。当回溯到第二层时，待归并的两个数组都是已经排好序的，最后再执行一次归并即可得到排序后的原数组。\n\n![](http://picbed.erjiangao.com/img/20200622012814.png)\n\n<!--more-->\n\n---\n\n**代码**\n\n```java\nimport java.util.Scanner;\n\npublic class MergeSortBook {\n    // auxiliay array\n    public static int[] aux;\n    \n    public static void merge(int[] a, int lo, int mid, int hi) {\n        int i = lo, j = mid + 1;\n        for (int k = lo; k <= hi; k++) {\n            aux[k] = a[k];\n        }\n        for (int k = lo; k <= hi; k++) {\n            if (i > mid)\n                a[k] = aux[j++];\n            else if (j > hi)\n                a[k] = aux[i++];\n            else if (aux[i] < aux[j])\n                a[k] = aux[i++];\n            else\n                a[k] = aux[j++];\n        }\n    }\n    \n    public static void mergeSortBook(int[] a, int lo, int hi) {\n        if (lo >= hi) {\n            return;\n        }\n        int mid = (lo + hi) / 2;\n        mergeSortBook(a, lo, mid);\n        mergeSortBook(a, mid + 1, hi);\n        merge(a, lo, mid, hi);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int a[] = new int[n];\n        aux = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        mergeSortBook(a, 0, n - 1);\n        for (int i = 0; i < a.length; i++) {\n            System.out.printf(\"%d \", a[i]);\n        }\n    }\n}\n\n```\n\n\n\n","tags":["算法"]},{"title":"快速排序算法","url":"/2020/03/29/快速排序算法/","content":"\n# Quick Sort\n\n## 经典快排\n\n快速排序算法采用分治思想，先随机选取一个`pivot`点，然后将数组分成两部分，左半部分小于`pivot`，右半部分大于`pivot`，然后这两部分别递归调用快排函数，当递归到达根节点之后数组已经完成排序。\n\n经典快排算法的关键是如何利用随机选出`pivot`点将数组分为两部分。分成两部分的方法是设立两个游标变量`i`和`j`，变量`i`从数组的左边往右边移动，`j`从右往左移动，每当`a[i]`大于`pivot`或者`a[j]`小于`pivot`时都会交换`a[i]`与`a[j]`以保证`pivot`左边的元素小于自己，右边的元素大于自己。\n\n<!--more-->\n\n---\n\n**代码**\n\n```java\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class QuickSort {\n    private static Random random = new Random();\n\n    public static void shuffle(int[] a) {\n        for (int i = a.length - 1; i > 0; i--) {\n            int index = random.nextInt(i + 1);\n            exch(a, index, i);\n        }\n    }\n\n    public static void exch(int[] a, int x, int y) {\n        int tmp = a[x];\n        a[x] = a[y];\n        a[y] = tmp;\n    }\n    \n    public static int partition(int[] a, int lo, int hi) {\n        int i = lo, j = hi + 1;\n        int pivotValue = a[lo];\n        while (true) {\n            while (a[++i] < pivotValue) {\n                if (i == hi) {\n                    break;\n                }\n            }\n            while (a[--j] > pivotValue) {\n                if (j == lo) {\n                    break;\n                }\n            }\n            if (i >= j) {\n                break;\n            }\n            exch(a, i, j);\n        }\n        exch(a, lo, j);\n        return j;\n    }\n    \n    public static void quickSort(int[] a, int lo, int hi) {\n        if (lo >= hi) {\n            return;\n        }\n        int pivot = partition(a, lo, hi);\n        quickSort(a, lo, pivot - 1);\n        quickSort(a, pivot + 1, hi);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        shuffle(a);\n        quickSort(a, 0, n - 1);\n        for (int i = 0; i < a.length; i++) {\n            System.out.printf(\"%d \", a[i]);\n        }\n    }\n}\n\n```\n\n## 算法改进\n\n**三向切分的快速排序**\n\n**代码**\n\n```java\nimport java.io.*;\nimport java.util.*;\n\npublic class ThreeWayQuickSort {\n    private static void exch(int[] a, int x, int y) {\n        int tmp = a[x];\n        a[x] = a[y];\n        a[y] = tmp;\n    }\n\n    private static void quickThreeWay(int[] a, int lo, int hi) {\n        if (lo >= hi) return;\n        int lt = lo, gt = hi, i = lo + 1;\n        int v = a[lo];\n        while (i <= gt) {\n            if (a[i] < v) {\n                exch(a, i++, lt++);\n            } else if (a[i] > v) {\n                exch(a, i, gt--);\n            } else {\n                i++;\n            }\n        }\n        quickThreeWay(a, lo, lt - 1);\n        quickThreeWay(a, gt + 1, hi);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        quickThreeWay(a, 0, n - 1);\n        for (int i = 0; i < n; i++) {\n            System.out.print(a[i] + \" \");\n        }\n    }\n}\n```\n\n","tags":["算法"]},{"title":"java数据结构 -- 队列","url":"/2020/03/19/java数据结构-队列/","content":"\n## 例题：\n\n**剑指offer [面试题09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)**\n\n思路：\n\n两个栈，一个栈`inStack`负责模拟进队列，另一个栈`outStack`负责模拟出队列，所有进队列的值全存在`inStack`中，直到出队列，出队列时先将`inStack`中的值全都放入`outStack`中，然后再将`outStack`出栈一次。\n\n<!--more-->\n\n---\n\n**代码**\n\n```java\nclass CQueue {\n    private Stack<Integer> inStack;\n    private Stack<Integer> outStack;\n\n    public CQueue() {\n        inStack = new Stack<Integer>();\n        outStack = new Stack<Integer>();\n    }\n    \n    public void appendTail(int value) {\n        inStack.add(value);\n    }\n    \n    public int deleteHead() {\n        if (outStack.isEmpty()) {\n            if (inStack.isEmpty()) {\n                return -1;\n            } \n            while (!inStack.isEmpty()) {\n                outStack.add(inStack.pop());\n            }\n            return outStack.pop();\n        } else {\n            return outStack.pop();\n        }\n    }\n}\n\n/**\n * Your CQueue object will be instantiated and called as such:\n * CQueue obj = new CQueue();\n * obj.appendTail(value);\n * int param_2 = obj.deleteHead();\n */\n```\n\n","tags":["数据结构"]},{"title":"java数据结构 -- 栈","url":"/2020/03/18/java数据结构 -- 栈/","content":"\n# Java Stack 类\n\n栈是Vector的一个子类，它实现了一个标准的后进先出的栈。\n\n堆栈只定义了默认构造函数，用来创建一个空栈。 堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。\n\n除了由Vector定义的所有方法，自己也定义了一些方法：\n\n<!--more-->\n\n| 函数签名                    |                                                  |\n| :-------------------------- | ------------------------------------------------ |\n| boolean isEmpty( )          | 测试堆栈是否为空。                               |\n| Object peek( )              | 查看堆栈顶部的对象，但不从堆栈中移除它。         |\n| Object pop( )               | 移除堆栈顶部的对象，并作为此函数的值返回该对象。 |\n| Object push(Object element) | 把项压入堆栈顶部。                               |\n| int search(Object element)  | 返回对象在堆栈中的位置，以 1 为基数。            |\n| int length( )               | 栈的长度                                         |\n| void clear( )               | 清空栈                                           |","tags":["数据结构"]},{"title":"My first small project - tutor selection tool","url":"/2020/03/17/My-first-small-project-tutor-selection-tool/","content":"\n# Graduation design tutor selection tool\n\n[Here](https://github.com/ErjianGao/tutor-selection-tool) is the location of this project in GitHub.\n\n## 更新记录\n\n<!--more-->\n\n- 2020年3月27日\n  - 为每个实体类添加插入时间\n  - 为学生添加密码 学号\n  - 为老师添加教工号\n- 2020年3月26日\n  \n  - 创建README的中文版本\n- 2020年3月24日\n  - 使用自定义的BaseRepository取代原生JpaRepository\n  - 测试实体类\n- 2020年3月23日\n  \n  - 为每个实体类创建JpaRepository\n- 2020年3月17日\n  \n  - 创建github page静态页面\n- 2020年3月16日\n  - 创建REAME文档\n  - 增加主页访客统计功能\n  - 创建6个实体类\n  - ![](http://picbed.erjiangao.com/img/20200622012843.png)\n- 2020年3月12日\n  - 创建MIT许可证\n- 2020年3月10日\n  \n  - 项目初始化，新建spring-boot工程\n\n","tags":["项目"]},{"title":"Test my site","url":"/2020/01/03/Test-my-site/","content":"\n# Hello Hexo!\n\nThis is my first article in my Internet blog. ","tags":["Hexo"]}]